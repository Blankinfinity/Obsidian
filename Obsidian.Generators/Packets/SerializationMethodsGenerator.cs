using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Obsidian.Generators.Packets
{
    [Generator]
    public class SerializationMethodsGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new ExecutionSyntaxProvider<MemberDeclarationSyntax>(member => (member is FieldDeclarationSyntax || member is PropertyDeclarationSyntax) && member.AttributeLists.Count > 0));
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is not ExecutionSyntaxProvider<MemberDeclarationSyntax> memberProvider)
                return;

            Compilation compilation = context.Compilation;

            INamedTypeSymbol attributeSymbol = compilation.GetTypeByMetadataName("Obsidian.Serializer.Attributes.FieldAttribute");

            var memberSymbols = new List<(TypeSyntax type, ISymbol symbol)>();
            foreach (MemberDeclarationSyntax member in memberProvider.WithContext(context).GetSyntaxNodes())
            {
                SemanticModel model = compilation.GetSemanticModel(member.SyntaxTree);
                if (member is FieldDeclarationSyntax field)
                {
                    foreach (VariableDeclaratorSyntax variable in field.Declaration.Variables)
                    {
                        ISymbol symbol = model.GetDeclaredSymbol(variable);
                        if (symbol.GetAttributes().Any(attribute => attribute.AttributeClass.Equals(attributeSymbol, SymbolEqualityComparer.Default)))
                        {
                            memberSymbols.Add((field.Declaration.Type, symbol));
                        }
                    }
                }
                else if (member is PropertyDeclarationSyntax property)
                {
                    ISymbol symbol = model.GetDeclaredSymbol(member);
                    if (symbol.GetAttributes().Any(attribute => attribute.AttributeClass.Equals(attributeSymbol, SymbolEqualityComparer.Default)))
                    {
                        memberSymbols.Add((property.Type, symbol));
                    }
                }
            }

            foreach (var group in memberSymbols.GroupBy(member => member.symbol.ContainingType))
            {
                string classSource = ProcessClass(group.Key, group.ToList(), attributeSymbol, context);
                context.AddSource($"{group.Key.Name}_Serialization.cs", SourceText.From(classSource, Encoding.UTF8));
            }    
        }

        /// <summary>
        /// <see cref=""/>
        /// </summary>
        /// <param name="classSymbol"></param>
        /// <returns></returns>
        private string ProcessClass(INamedTypeSymbol classSymbol, List<(TypeSyntax type, ISymbol symbol)> members, ISymbol attributeSymbol, GeneratorExecutionContext context)
        {
            string @namespace = classSymbol.ContainingNamespace.ToDisplayString();

            var source = new StringBuilder($@"using Obsidian.Net;

namespace {@namespace}
{{
    public partial class {classSymbol.Name}
    {{
");
            string classOffset = "\t\t";

            source.AppendXML("summary", $"Serializes data from this packet into <see cref=\"MinecraftStream\"/>.\n<b>AUTOGENERATED</b>");
            source.AppendXML("param", @"name=""stream""", "Target stream that this packet's data is written to.", true);
            source.Append($"{classOffset}public void Serialize(MinecraftStream stream)\n{classOffset}{{\n");
            CreateSerializationMethod(source, members);
            source.Append($"{classOffset}}}\n\n");

            source.AppendXML("summary", $"Deserializes byte data into <see cref=\"{classSymbol.Name}\"/> packet.\n<b>AUTOGENERATED</b>");
            source.AppendXML("param", @"name=""data""", "Data used to populate the packet.", true);
            source.AppendXML("returns", "Deserialized packet.", true);
            source.Append($"{classOffset}public static {classSymbol.Name} Deserialize(byte[] data)\n{classOffset}{{\n");
            source.AppendCode("using var stream = new MinecraftStream(data);");
            source.AppendCode("return Deserialize(stream);");
            source.Append($"{classOffset}}}\n\n");

            source.AppendXML("summary", $"Deserializes data from <see cref=\"MinecraftStream\"/> into <see cref=\"{classSymbol.Name}\"/> packet.\n<b>AUTOGENERATED</b>");
            source.AppendXML("param", @"name=""stream""", "Stream that is read from to populate the packet.", true);
            source.AppendXML("returns", "Deserialized packet.", true);
            source.Append($"{classOffset}public static {classSymbol.Name} Deserialize(MinecraftStream stream)\n{classOffset}{{\n");
            CreateDeserializationMethod(source, classSymbol, members);
            source.Append($"{classOffset}}}");

            source.Append(@"
    }
}");
            return source.ToString();
        }

        private void CreateSerializationMethod(StringBuilder builder, List<(TypeSyntax type, ISymbol symbol)> members)
        {

        }

        private void CreateDeserializationMethod(StringBuilder builder, INamedTypeSymbol classSymbol, List<(TypeSyntax type, ISymbol symbol)> members)
        {
            //builder.Append($"var packet = new {classSymbol}();");
            //foreach (var member in members)
            //{
            //    builder.Append($"packet.{member.symbol.Name} = stream.{GetReadMethod(member.type)}();");
            //}
            //builder.Append("return packet;");
            builder.AppendCode("return null;");
        }

        private string GetReadMethod(TypeSyntax type)
        {
            return string.Empty;
        }

        private string GetWriteMethod(TypeSyntax type)
        {
            return string.Empty;
        }

        private struct Member
        {
            public string Name { get; set; }
            public Type Type { get; set; }

            public Member(ISymbol symbol, FieldDeclarationSyntax field)
            {
                Name = symbol.Name;
                Type = null;
            }
        }
    }

    internal static class Extensions
    {
        private static readonly string prefix = "\t\t///";
        
        public static StringBuilder AppendXML(this StringBuilder stringBuilder, string type, string content, bool inline = false)
        {
            if (inline)
            {
                return stringBuilder.AppendLine($"{prefix} <{type}>{content.Replace('\n', ' ')}</{type}>");
            }
            else
            {
                return stringBuilder.AppendLine($"{prefix} <{type}>").AppendLine(string.Join("<br/>\n", content.Split('\n').Select(c => $"{prefix} {c}"))).AppendLine($"{prefix} </{type}>");
            }
        }

        public static StringBuilder AppendXML(this StringBuilder stringBuilder, string type, string attributes, string content, bool inline = false)
        {
            if (inline)
            {
                return stringBuilder.AppendLine($"{prefix} <{type} {attributes}>{content.Replace('\n', ' ')}</{type}>");
            }
            else
            {
                return stringBuilder.AppendLine($"{prefix} <{type} {attributes}>").AppendLine(string.Join("<br/>\n", content.Split('\n').Select(c => $"{prefix} {c}"))).AppendLine($"{prefix} </{type}>");
            }
        }

        public static StringBuilder AppendCode(this StringBuilder stringBuilder, string code)
        {
            return stringBuilder.AppendLine($"\t\t\t{code}");
        }
    }
}
